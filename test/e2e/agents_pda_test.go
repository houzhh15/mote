package e2e
package e2e

import (
	"fmt"
	"net/http"
	"testing"
)

// ================================================================
// PDA Agent CRUD & Validation E2E Tests
// These require a running mote server (env MOTE_TEST_URL or localhost:18788)
// ================================================================

func TestAgents_CreateStructuredAgent_ValidateCFG(t *testing.T) {
	if !isServerRunning() {
		t.Skip("Mote service not running, skipping e2e test")
	}










































































































































































































































































































}	return http.StatusOK	}		return actual	if actual == http.StatusCreated || actual == http.StatusOK {func respStatusOKOrCreated(actual int) int {// respStatusOKOrCreated normalizes expected status for create/update operations.}	cleanup.Body.Close()	cleanup := makeRequest(t, "DELETE", "/api/v1/agents/e2e-legacy", nil)	// Cleanup	}		}			t.Error("legacy agent should not have steps")		if isArr && len(stepsArr) > 0 {		stepsArr, isArr := steps.([]any)	if steps, ok := agentConfig["steps"]; ok && steps != nil {	// Steps should be nil/empty	}		t.Errorf("unexpected description: %v", agentConfig["description"])	if agentConfig["description"] != "Legacy agent without steps" {	agentConfig := agentResult["config"].(map[string]any)	parseResponse(t, resp, &agentResult)	var agentResult map[string]any	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "GET", "/api/v1/agents/e2e-legacy", nil)	// Get agent and verify no steps	parseResponse(t, resp, &result)	var result map[string]any	assertStatus(t, resp, respStatusOKOrCreated(resp.StatusCode))	}		resp = makeRequest(t, "PUT", "/api/v1/agents/e2e-legacy", agent["agent"])		resp.Body.Close()	if resp.StatusCode == http.StatusConflict {	resp := makeRequest(t, "POST", "/api/v1/agents", agent)	}		},			"max_depth":     3,			"system_prompt": "You are a helpful assistant",			"model":         "gpt-4",			"description":   "Legacy agent without steps",		"agent": map[string]any{		"name": "e2e-legacy",	agent := map[string]any{	// Create a traditional agent (no steps)	}		t.Skip("Mote service not running, skipping e2e test")	if !isServerRunning() {func TestAgents_LegacyAgent_NoSteps_Regression(t *testing.T) {}	}		resp.Body.Close()		resp := makeRequest(t, "DELETE", fmt.Sprintf("/api/v1/agents/%s", name), nil)	for _, name := range []string{"e2e-looper", "e2e-fallback"} {	// Cleanup	}		}			t.Error("should NOT have SELF_ROUTE_NO_LIMIT when max_recursion is set")		if rm["code"] == "SELF_ROUTE_NO_LIMIT" {		rm := r.(map[string]any)	for _, r := range results {	results = result["results"].([]any)	parseResponse(t, resp, &result)	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "POST", "/api/v1/agents/e2e-looper/validate-cfg", validateBody)	validateBody["max_recursion"] = 3	// Now validate WITH max_recursion — should be clean	}		t.Error("expected SELF_ROUTE_NO_LIMIT warning for self-referencing route without max_recursion")	if !foundWarning {	}		}			foundWarning = true		if rm["code"] == "SELF_ROUTE_NO_LIMIT" {		rm := r.(map[string]any)	for _, r := range results {	foundWarning := false	results := result["results"].([]any)	parseResponse(t, resp, &result)	var result map[string]any	assertStatus(t, resp, http.StatusOK)	resp := makeRequest(t, "POST", "/api/v1/agents/e2e-looper/validate-cfg", validateBody)	}		"max_recursion": 0,		},			},				},					"_default": "e2e-fallback",					"retry":    "e2e-looper",				"branches": map[string]string{				"prompt": "Is the output good enough?",				"label":  "quality-check",				"type":   "route",			{		"steps": []map[string]any{	validateBody := map[string]any{	// Validate a self-referencing route WITHOUT max_recursion	}		resp.Body.Close()		}			continue			resp.Body.Close()		if resp.StatusCode == http.StatusConflict {		resp := makeRequest(t, "POST", "/api/v1/agents", agent)		}			},				"description": fmt.Sprintf("%s agent", name),			"agent": map[string]any{			"name": name,		agent := map[string]any{	for _, name := range []string{"e2e-looper", "e2e-fallback"} {	// Create two agents for routing	}		t.Skip("Mote service not running, skipping e2e test")	if !isServerRunning() {func TestAgents_RouteRecursion_ValidationWarning(t *testing.T) {}	cleanup.Body.Close()	cleanup := makeRequest(t, "DELETE", "/api/v1/agents/e2e-draft-test", nil)	// Cleanup	}		t.Error("expected draft to be nil after discard")	if agentConfig["draft"] != nil {	agentConfig = agentResult["config"].(map[string]any)	parseResponse(t, resp, &agentResult)	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "GET", "/api/v1/agents/e2e-draft-test", nil)	// Verify draft is gone	}		t.Errorf("expected draft_discarded=true, got %v", discardResult["draft_discarded"])	if discardResult["draft_discarded"] != true {	parseResponse(t, resp, &discardResult)	var discardResult map[string]any	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "DELETE", "/api/v1/agents/e2e-draft-test/draft", nil)	// Discard draft	}		t.Error("expected draft field in agent config")	if agentConfig["draft"] == nil {	agentConfig := agentResult["config"].(map[string]any)	parseResponse(t, resp, &agentResult)	var agentResult map[string]any	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "GET", "/api/v1/agents/e2e-draft-test", nil)	// Verify agent has draft	}		t.Error("expected saved_at in response")	if _, ok := saveResult["saved_at"]; !ok {	}		t.Errorf("expected name=e2e-draft-test, got %v", saveResult["name"])	if saveResult["name"] != "e2e-draft-test" {	parseResponse(t, resp, &saveResult)	var saveResult map[string]any	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "POST", "/api/v1/agents/e2e-draft-test/draft", draftBody)	}		},			{"type": "prompt", "label": "draft-step", "content": "Draft prompt"},		"steps": []map[string]any{	draftBody := map[string]any{	// Save a draft	resp.Body.Close()	}		resp = makeRequest(t, "PUT", "/api/v1/agents/e2e-draft-test", agent["agent"])		resp.Body.Close()	if resp.StatusCode == http.StatusConflict {	resp := makeRequest(t, "POST", "/api/v1/agents", agent)	}		},			"description": "draft test agent",		"agent": map[string]any{		"name": "e2e-draft-test",	agent := map[string]any{	// First create a simple agent	}		t.Skip("Mote service not running, skipping e2e test")	if !isServerRunning() {func TestAgents_Draft_SaveAndDiscard(t *testing.T) {}	}		t.Errorf("expected MISSING_AGENT_REF validation error, got: %v", results)	if !foundMissing {	}		}			foundMissing = true		if rm["code"] == "MISSING_AGENT_REF" {		rm := r.(map[string]any)	for _, r := range results {	foundMissing := false	results := result["results"].([]any)	parseResponse(t, resp, &result)	var result map[string]any	assertStatus(t, resp, http.StatusOK)	resp := makeRequest(t, "POST", "/api/v1/agents/any-agent/validate-cfg", validateBody)	}		"max_recursion": 0,		},			{"type": "agent_ref", "label": "call-missing", "agent": "nonexistent-agent-12345"},		"steps": []map[string]any{	validateBody := map[string]any{	}		t.Skip("Mote service not running, skipping e2e test")	if !isServerRunning() {func TestAgents_ValidateCFG_MissingAgent(t *testing.T) {}	cleanup.Body.Close()	cleanup := makeRequest(t, "DELETE", "/api/v1/agents/e2e-structured", nil)	// Cleanup	}		t.Errorf("expected 0 validation errors for valid config, got %d: %v", len(results), results)	if len(results) != 0 {	}		t.Fatal("expected results array in validate-cfg response")	if !ok {	results, ok := valResult["results"].([]any)	parseResponse(t, resp, &valResult)	var valResult map[string]any	assertStatus(t, resp, http.StatusOK)	resp = makeRequest(t, "POST", "/api/v1/agents/e2e-structured/validate-cfg", validateBody)	}		"max_recursion": 0,		},			{"type": "prompt", "label": "step3", "content": "Say goodbye"},			{"type": "prompt", "label": "step2", "content": "Summarize the conversation"},			{"type": "prompt", "label": "step1", "content": "Introduce yourself"},		"steps": []map[string]any{	validateBody := map[string]any{	// Validate CFG — should return 0 errors	parseResponse(t, resp, &result)	var result map[string]any	assertStatus(t, resp, respStatusOKOrCreated(resp.StatusCode))	}		resp = makeRequest(t, "PUT", "/api/v1/agents/e2e-structured", agent["agent"])		resp.Body.Close()		// Agent exists, update instead	if resp.StatusCode == http.StatusConflict {	resp := makeRequest(t, "POST", "/api/v1/agents", agent)	}		},			},				{"type": "prompt", "label": "step3", "content": "Say goodbye"},				{"type": "prompt", "label": "step2", "content": "Summarize the conversation"},				{"type": "prompt", "label": "step1", "content": "Introduce yourself"},			"steps": []map[string]any{			"system_prompt": "You are a test agent",			"description":   "E2E test structured agent",		"agent": map[string]any{		"name": "e2e-structured",	agent := map[string]any{	// Create a structured agent with 3 prompt steps